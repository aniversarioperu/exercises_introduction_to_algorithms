\begin{description}
 \item[2.3-1] Merge sort.
 \begin{center}
 \includegraphics[width=200px]{chapter2/merge_sort.pdf}
 % 2.1-1.png: 39x65 pixel, 9dpi, 11.02x18.36 cm, bb=0 0 312 520
 \end{center}

\item[2.3-2] Modified merge procedure
\begin{lstlisting}
A = [p, ... q, ... r]

n1 = q - p + 1
n2 = r - q

L = [i for i in A[1:n1]]
R = [i for i in A[1:n2]]

i, j = 1, 1

for k in p..r:
  if L[i] <= R[j]:
    A[k] = L[i]
    if i == n1:
      A[k+1..r] = R[j..n2]
      break
    i += 1

  else:
    A[k] = R[j]
    if j == n2:
      A[k+1..r] = L[i..n1]
      break
    j += 1
\end{lstlisting}


\item[2.3-5] Binary search algorithm.
\begin{lstlisting}

def search(A):
  index = len(A)/2
  
  if A(index) == v:
    return index
  else:
    if A(index) > v:
      search(A[1:index)
    else:
      search(A[index+1:n)
\end{lstlisting}
In the worst case scenario the needed index with be the last item in the list. Then the
algorithm will have to split the list $n/2 + n/4 + n/8 = n(logn)\dfrac{}{}$


\item[2.3-6] Insertion sort with binary search. Splitting the loops saves time but it will still be necessary
to move the item along the subarrays. So the running time cannot be improved better than $\Theta(n^2)$.

\end{description}


